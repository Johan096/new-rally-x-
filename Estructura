import pygame
import random
import math

# Inicialización de Pygame
pygame.init()

# Configuración de pantalla
WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("New Rally X")

# Colores
WHITE = (255, 255, 255)
RED = (255, 0, 0)
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0)

# Fuente
font = pygame.font.Font(None, 36)

def draw_text(text, x, y, color=BLACK):
    render = font.render(text, True, color)
    screen.blit(render, (x, y))

# Clase Bullet
class Bullet:
    def __init__(self, x, y, angle):
        self.x = x
        self.y = y
        self.speed = 6
        self.angle = angle
        self.rect = pygame.Rect(self.x, self.y, 10, 10)
    
    def move(self):
        if self.angle == 0:  # Mueve a la derecha
            self.x += self.speed
        elif self.angle == 280:  # Mueve a la izquierda
            self.x -= self.speed
        elif self.angle == 270:  # Mueve hacia arriba
            self.y -= self.speed
        elif self.angle == 190:  # Mueve hacia abajo
            self.y += self.speed
        self.rect.topleft = (self.x, self.y)
    
    def draw(self):
        pygame.draw.rect(screen, YELLOW, self.rect)

# Clase Player
class Player:
    def __init__(self):
        self.x = 100
        self.y = 100
        self.speed = 4
        self.rect = pygame.Rect(self.x, self.y, 40, 40)
        self.defending = False
        # Cargar la imagen del jugador
        try:
            self.image = pygame.image.load("player01_.png") 
            self.image = pygame.transform.scale(self.image, (55, 55))  # Escalar la imagen
        except pygame.error:
            print("No se pudo cargar la imagen 'player01_.png'. Usando un color de fondo.")
            self.image = pygame.Surface((55, 55))  # Superficie de reemplazo
            self.image.fill(RED)
        self.angle = 0  # Ángulo de rotación inicial
        self.bullets = []  # Lista de balas
        self.can_shoot = True  # Para evitar disparos continuos
        self.coins_collected = 0  # Monedas recogidas
        self.health = 100  # Salud inicial

    def move(self, keys):
        original_x, original_y = self.x, self.y

        if keys[pygame.K_LEFT]:
            self.x -= self.speed
            self.angle = 180  # Mira hacia la izquierda
        if keys[pygame.K_RIGHT]:
            self.x += self.speed
            self.angle = 0  # Mira hacia la derecha
        if keys[pygame.K_UP]:
            self.y -= self.speed
            self.angle = 70  # Mira hacia arriba
        if keys[pygame.K_DOWN]:
            self.y += self.speed
            self.angle = 90  # Mira hacia abajo

        # Restricciones para no salir de la pantalla
        if self.x < 0:  # No puede pasar de la izquierda
            self.x = 0
        if self.x + self.rect.width > WIDTH:  # No puede pasar de la derecha
            self.x = WIDTH - self.rect.width
        if self.y < 0:  # No puede pasar de arriba
            self.y = 0
        if self.y + self.rect.height > HEIGHT:  # No puede pasar de abajo
            self.y = HEIGHT - self.rect.height

        self.rect.topleft = (self.x, self.y)

    def draw(self):
        # Rotamos la imagen según el ángulo
        rotated_image = pygame.transform.rotate(self.image, self.angle)
        rotated_rect = rotated_image.get_rect(center=self.rect.center)  # Ajustamos el rectángulo de la imagen para que se dibujue correctamente
        screen.blit(rotated_image, rotated_rect.topleft)  # Dibujamos la imagen rotada

        # Dibujar las balas
        for bullet in self.bullets:
            bullet.move()
            bullet.draw()
            if bullet.x > WIDTH or bullet.x < 0 or bullet.y < 0 or bullet.y > HEIGHT:
                self.bullets.remove(bullet)

        # Mostrar las monedas recogidas
        draw_text(f"Monedas: {self.coins_collected}", 10, 10, RED)

        # Mostrar la salud del jugador
        draw_text(f"Salud: {self.health}", WIDTH - 150, 10, RED)

    def shoot(self):
        # Solo disparar cuando el jugador presiona la tecla de espacio
        self.bullets.append(Bullet(self.x + 40, self.y + 15, self.angle))  # Crear la bala según la dirección del jugador

# Clase Coin (Moneda)
class Coin:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.rect = pygame.Rect(self.x, self.y, 20, 20)
    
    def draw(self):
        pygame.draw.circle(screen, YELLOW, (self.x + 10, self.y + 10), 10)  # Dibujar la moneda como un círculo

# Clase Enemy (Enemigo)
class Enemy:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.speed = 2
        self.rect = pygame.Rect(self.x, self.y, 50, 50)
        self.direction = random.choice([0, 90, 180, 270])  # Dirección aleatoria (0: derecha, 90: abajo, 180: izquierda, 270: arriba)
        self.patrol_points = [(self.x, self.y), (random.randint(200, WIDTH - 200), random.randint(200, HEIGHT - 200))]
        self.current_patrol_point = 0  # Usamos un punto de patrullaje

        try:
            self.image = pygame.image.load("enemigos01.png")  # Cargar la imagen de los enemigos
            self.image = pygame.transform.scale(self.image, (50, 50))  # Escalar la imagen
        except pygame.error:
            print("No se pudo cargar la imagen 'enemigos01.png'. Usando un color de fondo.")
            self.image = pygame.Surface((50, 50))  # Superficie de reemplazo

    def patrol(self):
        # Patrullar entre puntos
        target_x, target_y = self.patrol_points[self.current_patrol_point]
        dx = target_x - self.x
        dy = target_y - self.y
        distance = math.sqrt(dx**2 + dy**2)

        if distance < 3:  # Si llegó al punto de patrullaje
            self.current_patrol_point = (self.current_patrol_point + 1) % len(self.patrol_points)  # Cambia al siguiente punto

        if distance != 0:
            dx, dy = dx / distance, dy / distance  # Normalizamos el movimiento

        self.x += self.speed * dx
        self.y += self.speed * dy
        self.rect.topleft = (self.x, self.y)

    def move(self, player):
        # Si el jugador está cerca, mover al enemigo hacia el jugador
        dx = player.x - self.x
        dy = player.y - self.y
        distance = math.sqrt(dx**2 + dy**2)

        if distance < 200:  # Si el jugador está dentro del rango de 200 píxeles
            if distance != 0:
                dx, dy = dx / distance, dy / distance  # Normalizamos el movimiento

            # Actualizar la posición del enemigo
            self.x += self.speed * dx
            self.y += self.speed * dy
        else:
            self.patrol()  # Si no está cerca, patrullará

        # Limitar el movimiento de los enemigos para que no salgan de la pantalla
        if self.x < 0: self.x = 0
        if self.x + self.rect.width > WIDTH: self.x = WIDTH - self.rect.width
        if self.y < 0: self.y = 0
        if self.y + self.rect.height > HEIGHT: self.y = HEIGHT - self.rect.height
        
        self.rect.topleft = (self.x, self.y)

    def draw(self):
        # Dibujar el enemigo con la imagen cargada
        screen.blit(self.image, self.rect.topleft)

    def attack(self, player):
        # Si el enemigo está cerca del jugador, el enemigo lo atacará
        if self.rect.colliderect(player.rect):
            player.health -= 1  # Reducir la salud del jugador cuando el enemigo lo toque

    def hit_by_bullet(self, bullets):
        # Si una bala toca al enemigo, el enemigo muere
        for bullet in bullets:
            if self.rect.colliderect(bullet.rect):
                return True
        return False

# Función para mostrar el menú con fondo
def main_menu(sound_enabled):
    menu_running = True
    menu_options = ["Empezar Juego", f"Sonido: {'ON' if sound_enabled else 'OFF'}", "Salir"]
    selected_option = 0  # Índice de la opción seleccionada
    
    # Intentamos cargar la imagen del fondo
    try:
        background = pygame.image.load("fondo_menu.jpg")
        background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Escalamos la imagen al tamaño de la pantalla
    except pygame.error:
        print("No se pudo cargar la imagen 'fondo_menu.jpg'. Usando color de fondo.")
        background = pygame.Surface((WIDTH, HEIGHT))  # Superficie de reemplazo en caso de error
        background.fill(WHITE)

    while menu_running:
        screen.blit(background, (0, 0))  # Dibujamos el fondo

        # Dibujar las opciones del menú
        for i, option in enumerate(menu_options):
            # Sombrear la opción seleccionada
            if i == selected_option:
                draw_text(option, 300, 200 + i * 50, color=RED)  # Sombra con rojo
            else:
                draw_text(option, 300, 200 + i * 50)

        pygame.display.flip()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP:  # Tecla de subir
                    selected_option = (selected_option - 1) % len(menu_options)
                if event.key == pygame.K_DOWN:  # Tecla de bajar
                    selected_option = (selected_option + 1) % len(menu_options)
                if event.key == pygame.K_RETURN:  # Tecla Enter para seleccionar
                    if selected_option == 0:
                        return "start", sound_enabled
                    elif selected_option == 1:
                        sound_enabled = not sound_enabled  # Alternar estado del sonido
                        return "pause", sound_enabled
                    elif selected_option == 2:
                        pygame.quit()
                        exit()

def game_loop():
    ticking = True
    clock = pygame.time.Clock()
    
    # Cargar la imagen de fondo
    try:
        background = pygame.image.load("background.jpg")
        background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Escalamos la imagen al tamaño de la pantalla
    except pygame.error:
        print("No se pudo cargar la imagen 'background1.jpg'. Usando color de fondo.")
        background = pygame.Surface((WIDTH, HEIGHT))  # Superficie de reemplazo en caso de error
        background.fill(WHITE)

    # Definir la meta (meta de destino)
    goal_rect = pygame.Rect(WIDTH - 100, HEIGHT - 100, 50, 50)  # Rectángulo de la meta en la esquina inferior derecha
    
    # Crear las monedas en diferentes posiciones
    coins = [
        Coin(150, 200), 
        Coin(350, 300), 
        Coin(600, 250),
        Coin(500, 100),
        Coin(200, 500)
    ]
    
    # Crear enemigos en posiciones alejadas del jugador
    enemies = []
    for _ in range(5):
        # Evitamos que los enemigos aparezcan cerca del jugador
        while True:
            x = random.randint(200, WIDTH - 200)  # Aseguramos que estén alejados de las áreas cercanas al jugador
            y = random.randint(200, HEIGHT - 200)
            if abs(x - 100) > 100 and abs(y - 100) > 100:  # Aseguramos que estén lejos del jugador
                enemies.append(Enemy(x, y))
                break
    
    sound_enabled = True  # Estado del sonido
    
    while ticking:
        state, sound_enabled = main_menu(sound_enabled)  # Regresa al menú después de cada partida
        paused = False
        game_over = False
        win = False
        player = Player()
        
        while state == "start" and not game_over and not win:
            screen.blit(background, (0, 0))  # Dibujar el fondo con la imagen

            keys = pygame.key.get_pressed()
            player.move(keys)
            
            # Si se presiona la tecla de espacio, disparar
            if keys[pygame.K_SPACE]:
                player.shoot()

            player.draw()

            # Comprobar si el jugador llega a la meta
            if player.rect.colliderect(goal_rect):
                win = True

            # Dibujar la meta
            pygame.draw.rect(screen, GREEN, goal_rect)

            # Dibujar monedas y verificar colisiones con el jugador
            for coin in coins[:]:
                coin.draw()
                if player.rect.colliderect(coin.rect):
                    player.coins_collected += 1  # Incrementar las monedas recogidas
                    coins.remove(coin)  # Eliminar la moneda recogida

            # Mover y dibujar enemigos
            for enemy in enemies[:]:
                enemy.move(player)
                enemy.draw()
                enemy.attack(player)  # Los enemigos atacan al jugador
                if enemy.hit_by_bullet(player.bullets):  # Verificar si el enemigo fue golpeado por una bala
                    enemies.remove(enemy)  # Eliminar el enemigo

            # Verificar si el jugador es tocado por algún enemigo
            for enemy in enemies:
                if player.rect.colliderect(enemy.rect):
                    game_over = True
                    break

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    ticking = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_2:
                        paused = not paused
                    if event.key == pygame.K_3:
                        ticking = False
            
            if paused:
                draw_text("PAUSE", WIDTH // 2 - 50, HEIGHT // 2, BLACK)
                pygame.display.flip()
                while paused:
                    for event in pygame.event.get():
                        if event.type == pygame.QUIT:
                            ticking = False
                            paused = False
                        if event.type == pygame.KEYDOWN and event.key == pygame.K_2:
                            paused = False
                    pygame.time.delay(100)
            else:
                pygame.display.flip()
                clock.tick(30)
        
        if game_over:
            screen.fill(WHITE)
            draw_text("GAME OVER", WIDTH // 2 - 80, HEIGHT // 2, RED)
            pygame.display.flip()
            pygame.time.delay(2000)
        
        if win:
            screen.fill(WHITE)
            draw_text(f"YOU WIN! Monedas: {player.coins_collected}", WIDTH // 2 - 100, HEIGHT // 2, GREEN)
            pygame.display.flip()
            pygame.time.delay(2000)

# Iniciar el juego
game_loop()
pygame.quit()
