import pygame
import random
import math
import heapq

# Inicialización de Pygame
pygame.init()

# Configuración de pantalla
WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("New Rally X")

# Colores
WHITE = (255, 255, 255)
RED = (255, 0, 0)
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0)

# Fuente
font = pygame.font.Font(None, 36)

def draw_text(text, x, y, color=BLACK):
    render = font.render(text, True, color)
    screen.blit(render, (x, y))

# Clase para representar las celdas del mapa (nodos de A*)
class Node:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.g = float('inf')  # Coste desde el nodo inicial
        self.h = 0  # Heurística (estimación al destino)
        self.f = self.g + self.h  # Valor total (g + h)
        self.parent = None  # Nodo anterior en el camino

    def __lt__(self, other):
        return self.f < other.f

# Función A* para encontrar el camino
def a_star(start, goal, grid, width, height):
    open_list = []
    closed_list = set()
    heapq.heappush(open_list, (start.f, start))

    while open_list:
        current_node = heapq.heappop(open_list)[1]
        if current_node == goal:
            path = []
            while current_node:
                path.append((current_node.x, current_node.y))
                current_node = current_node.parent
            return path[::-1]  # Devolver el camino invertido
        closed_list.add(current_node)

        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  # Movimientos: izquierda, derecha, arriba, abajo
            neighbor_x = current_node.x + dx
            neighbor_y = current_node.y + dy
            if 0 <= neighbor_x < width and 0 <= neighbor_y < height:
                if grid[neighbor_y][neighbor_x] == 1:  # Si la celda está bloqueada
                    continue
                neighbor = grid[neighbor_y][neighbor_x]
                if neighbor in closed_list:
                    continue
                tentative_g = current_node.g + 1  # Coste de movimiento
                if tentative_g < neighbor.g:
                    neighbor.g = tentative_g
                    neighbor.h = abs(neighbor.x - goal.x) + abs(neighbor.y - goal.y)  # Heurística: distancia Manhattan
                    neighbor.f = neighbor.g + neighbor.h
                    neighbor.parent = current_node
                    heapq.heappush(open_list, (neighbor.f, neighbor))

    return None  # No hay camino

# Clase para el jugador
class Player:
    def __init__(self):
        self.x = 100
        self.y = 100
        self.speed = 4
        self.rect = pygame.Rect(self.x, self.y, 40, 40)
        self.image = pygame.Surface((40, 40))  # Usar una superficie para el jugador
        self.image.fill(RED)
    
    def move(self, keys):
        if keys[pygame.K_LEFT]:
            self.x -= self.speed
        if keys[pygame.K_RIGHT]:
            self.x += self.speed
        if keys[pygame.K_UP]:
            self.y -= self.speed
        if keys[pygame.K_DOWN]:
            self.y += self.speed

        self.rect.topleft = (self.x, self.y)
    
    def draw(self):
        screen.blit(self.image, self.rect.topleft)

# Clase para los enemigos
class Enemy:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.speed = 1
        self.rect = pygame.Rect(self.x, self.y, 50, 50)
        self.image = pygame.Surface((50, 50))  # Usar una superficie para los enemigos
        self.image.fill(BLUE)
    
    def move(self, player, grid, width, height):
        start = Node(self.x // 40, self.y // 40)  # Convertir las coordenadas a celdas
        goal = Node(player.x // 40, player.y // 40)
        
        # Crear la cuadrícula de nodos
        grid_nodes = [[Node(x, y) for x in range(width)] for y in range(height)]
        # Configurar las celdas bloqueadas
        for y in range(height):
            for x in range(width):
                if grid[y][x] == 1:  # Si es una celda bloqueada (por ejemplo, pared)
                    grid_nodes[y][x].f = float('inf')  # Marcarla como bloqueada

        path = a_star(start, goal, grid_nodes, width, height)  # Buscar el camino
        if path:
            # Mover al enemigo hacia el siguiente punto en el camino
            next_x, next_y = path[1]  # El siguiente nodo en el camino
            self.x = next_x * 40
            self.y = next_y * 40
            self.rect.topleft = (self.x, self.y)
    
    def draw(self):
        screen.blit(self.image, self.rect.topleft)

# Función para crear un mapa con obstáculos
def create_map(width, height):
    grid = [[0 for _ in range(width)] for _ in range(height)]  # 0 = libre, 1 = bloqueado
    for _ in range(50):  # Crear obstáculos aleatorios
        x = random.randint(0, width - 1)
        y = random.randint(0, height - 1)
        grid[y][x] = 1
    return grid

# Función principal del juego
def game_loop():
    width, height = 20, 15  # Tamaño de la cuadrícula
    ticking = True
    clock = pygame.time.Clock()

    grid = create_map(width, height)  # Crear el mapa
    player = Player()
    enemies = [Enemy(random.randint(5, width-5)*40, random.randint(5, height-5)*40) for _ in range(3)]
    
    while ticking:
        screen.fill(WHITE)
        
        # Dibujar la cuadrícula (mapa con obstáculos)
        for y in range(height):
            for x in range(width):
                color = WHITE if grid[y][x] == 0 else BLACK
                pygame.draw.rect(screen, color, (x * 40, y * 40, 40, 40))

        keys = pygame.key.get_pressed()
        player.move(keys)
        player.draw()

        # Mover enemigos utilizando A*
        for enemy in enemies:
            enemy.move(player, grid, width, height)
            enemy.draw()

        pygame.display.flip()
        clock.tick(60)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                ticking = False
                
# Clase Bullet
class Bullet:
    def __init__(self, x, y, angle):
        self.x = x
        self.y = y
        self.speed = 6
        self.angle = angle
        self.rect = pygame.Rect(self.x, self.y, 10, 10)
    
    def move(self):
        if self.angle == 0:  # Mueve a la derecha
            self.x += self.speed
        elif self.angle == 180:  # Mueve a la izquierda
            self.x -= self.speed
        elif self.angle == 270:  # Mueve hacia arriba
            self.y -= self.speed
        elif self.angle == 90:  # Mueve hacia abajo
            self.y += self.speed
        self.rect.topleft = (self.x, self.y)
    
    def draw(self):
        pygame.draw.rect(screen, YELLOW, self.rect)

# Clase Player
class Player:
    def __init__(self):
        self.x = 100
        self.y = 100
        self.speed = 4
        self.rect = pygame.Rect(self.x, self.y, 40, 40)
        self.defending = False
        # Cargar la imagen del jugador
        try:
            self.image = pygame.image.load("player01_.png") 
            self.image = pygame.transform.scale(self.image, (55, 55))  # Escalar la imagen
        except pygame.error:
            print("No se pudo cargar la imagen 'player01_.png'. Usando un color de fondo.")
            self.image = pygame.Surface((55, 55))  # Superficie de reemplazo
            self.image.fill(RED)
        self.angle = 0  # Ángulo de rotación inicial
        self.bullets = []  # Lista de balas
        self.can_shoot = True  # Para evitar disparos continuos
        self.coins_collected = 0  # Monedas recogidas
        self.health = 100  # Salud inicial

    def move(self, keys):
        original_x, original_y = self.x, self.y

        if keys[pygame.K_LEFT]:
            self.x -= self.speed
            self.angle = 180  # Mira hacia la izquierda
        if keys[pygame.K_RIGHT]:
            self.x += self.speed
            self.angle = 0  # Mira hacia la derecha
        if keys[pygame.K_UP]:
            self.y -= self.speed
            self.angle = 270  # Mira hacia arriba
        if keys[pygame.K_DOWN]:
            self.y += self.speed
            self.angle = 90  # Mira hacia abajo

        # Restricciones para no salir de la pantalla
        if self.x < 0:  # No puede pasar de la izquierda
            self.x = 0
        if self.x + self.rect.width > WIDTH:  # No puede pasar de la derecha
            self.x = WIDTH - self.rect.width
        if self.y < 0:  # No puede pasar de arriba
            self.y = 0
        if self.y + self.rect.height > HEIGHT:  # No puede pasar de abajo
            self.y = HEIGHT - self.rect.height

        self.rect.topleft = (self.x, self.y)

    def draw(self):
        # Rotamos la imagen según el ángulo
        rotated_image = pygame.transform.rotate(self.image, self.angle)
        rotated_rect = rotated_image.get_rect(center=self.rect.center)  # Ajustamos el rectángulo de la imagen para que se dibujue correctamente
        screen.blit(rotated_image, rotated_rect.topleft)  # Dibujamos la imagen rotada

        # Dibujar las balas
        for bullet in self.bullets:
            bullet.move()
            bullet.draw()
            if bullet.x > WIDTH or bullet.x < 0 or bullet.y < 0 or bullet.y > HEIGHT:
                self.bullets.remove(bullet)

        # Mostrar las monedas recogidas
        draw_text(f"Monedas: {self.coins_collected}", 10, 10, RED)

        # Mostrar la salud del jugador
        draw_text(f"Salud: {self.health}", WIDTH - 150, 10, RED)

    def shoot(self):
        # Solo disparar cuando el jugador presiona la tecla de espacio
        self.bullets.append(Bullet(self.x + 40, self.y + 15, self.angle))  # Crear la bala según la dirección del jugador

# Clase Coin (Moneda)
class Coin:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.rect = pygame.Rect(self.x, self.y, 45, 45)
        try:
            self.image = pygame.image.load("moneda.jpg")  # Cargar la imagen de la moneda
            self.image = pygame.transform.scale(self.image, (45, 45))  # Escalar la imagen a un tamaño adecuado
        except pygame.error:
            print("No se pudo cargar la imagen 'moneda.jpg'. Usando un color de fondo.")
            self.image = pygame.Surface((45, 45))  # Superficie de reemplazo en caso de error
            self.image.fill(YELLOW)  # Rellenar con un color para indicar que la imagen no se cargó

    def draw(self):
        # Dibujar la moneda con la imagen cargada
        screen.blit(self.image, self.rect.topleft)


# Clase Enemy (Enemigo)
class Enemy:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.speed = 1
        self.rect = pygame.Rect(self.x, self.y, 50, 50)
        self.direction = random.choice([0, 90, 180, 270])  # Dirección aleatoria
        self.patrol_points = [(self.x, self.y), (random.randint(200, WIDTH - 200), random.randint(200, HEIGHT - 200))]
        self.current_patrol_point = 0  # Usamos un punto de patrullaje

        try:
            self.image = pygame.image.load("enemigos01.png")  # Cargar la imagen del enemigo
            self.image = pygame.transform.scale(self.image, (50, 50))  # Escalar la imagen
        except pygame.error:
            print("No se pudo cargar la imagen 'enemigos01.png'. Usando un color de fondo.")
            self.image = pygame.Surface((50, 50))  # Superficie de reemplazo

    def patrol(self):
        # Patrullar entre puntos
        target_x, target_y = self.patrol_points[self.current_patrol_point]
        dx = target_x - self.x
        dy = target_y - self.y
        distance = math.sqrt(dx**2 + dy**2)

        if distance < 3:  # Si llegó al punto de patrullaje
            self.current_patrol_point = (self.current_patrol_point + 1) % len(self.patrol_points)  # Cambia al siguiente punto

        if distance != 0:
            dx, dy = dx / distance, dy / distance  # Normalizamos el movimiento

        self.x += self.speed * dx
        self.y += self.speed * dy
        self.rect.topleft = (self.x, self.y)

    def move(self, player):
        # Árbol de comportamiento para el enemigo
        # Comportamiento basado en distancia al jugador
        dx = player.x - self.x
        dy = player.y - self.y
        distance = math.sqrt(dx**2 + dy**2)

        # Si el jugador está dentro del rango de 200 píxeles
        if distance < 200:
            # Decisión: acercarse al jugador
            self.approach_player(dx, dy, distance)
        else:
            # Si no está cerca, patrullar
            self.patrol()

        # Limitar el movimiento de los enemigos para que no salgan de la pantalla
        if self.x < 0: self.x = 0
        if self.x + self.rect.width > WIDTH: self.x = WIDTH - self.rect.width
        if self.y < 0: self.y = 0
        if self.y + self.rect.height > HEIGHT: self.y = HEIGHT - self.rect.height
        
        self.rect.topleft = (self.x, self.y)

    def approach_player(self, dx, dy, distance):
        # Decisión para acercarse al jugador
        if distance != 0:
            dx, dy = dx / distance, dy / distance  # Normalizamos el movimiento
        self.x += self.speed * dx
        self.y += self.speed * dy

    def draw(self):
        # Dibujar el enemigo con la imagen cargada
        screen.blit(self.image, self.rect.topleft)

    def attack(self, player):
        # Si el enemigo está cerca del jugador, el enemigo lo atacará
        if self.rect.colliderect(player.rect):
            player.health -= 1  # Reducir la salud del jugador cuando el enemigo lo toque

    def hit_by_bullet(self, bullets):
        # Si una bala toca al enemigo, el enemigo muere
        for bullet in bullets:
            if self.rect.colliderect(bullet.rect):
                return True
        return False


# Función para mostrar el menú con fondo
def main_menu(sound_enabled):
    menu_running = True
    menu_options = ["Empezar Juego", f"Sonido: {'ON' if sound_enabled else 'OFF'}", "Salir"]
    selected_option = 0  # Índice de la opción seleccionada
    
    # Intentamos cargar la imagen del fondo
    try:
        background = pygame.image.load("fondo_menu.jpg")
        background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Escalamos la imagen al tamaño de la pantalla
    except pygame.error:
        print("No se pudo cargar la imagen 'fondo_menu.jpg'. Usando color de fondo.")
        background = pygame.Surface((WIDTH, HEIGHT))  # Superficie de reemplazo en caso de error
        background.fill(WHITE)

    while menu_running:
        screen.blit(background, (0, 0))  # Dibujamos el fondo

        # Dibujar las opciones del menú
        for i, option in enumerate(menu_options):
            # Sombrear la opción seleccionada
            if i == selected_option:
                draw_text(option, 300, 200 + i * 50, color=RED)  # Sombra con rojo
            else:
                draw_text(option, 300, 200 + i * 50)

        pygame.display.flip()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP:  # Tecla de subir
                    selected_option = (selected_option - 1) % len(menu_options)
                if event.key == pygame.K_DOWN:  # Tecla de bajar
                    selected_option = (selected_option + 1) % len(menu_options)
                if event.key == pygame.K_RETURN:  # Tecla Enter para seleccionar
                    if selected_option == 0:
                        return "start", sound_enabled
                    elif selected_option == 1:
                        sound_enabled = not sound_enabled  # Alternar estado del sonido
                        return "pause", sound_enabled
                    elif selected_option == 2:
                        pygame.quit()
                        exit()

def game_loop():
    ticking = True
    clock = pygame.time.Clock()

    # Cargar la imagen de fondo
    try:
        background = pygame.image.load("background.jpg")
        background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Escalamos la imagen al tamaño de la pantalla
    except pygame.error:
        print("No se pudo cargar la imagen 'background1.jpg'. Usando color de fondo.")
        background = pygame.Surface((WIDTH, HEIGHT))  # Superficie de reemplazo en caso de error
        background.fill(WHITE)

    # Crear el mapa, jugador y enemigos
    def restart_game():
        goal_rect = pygame.Rect(WIDTH - 100, HEIGHT - 100, 50, 50)
        coins = [Coin(150, 200), Coin(350, 300), Coin(600, 250),
                 Coin(500, 100), Coin(200, 500)]
        enemies = []
        for _ in range(5):
            while True:
                x = random.randint(200, WIDTH - 200)
                y = random.randint(200, HEIGHT - 200)
                if abs(x - 100) > 100 and abs(y - 100) > 100:
                    enemies.append(Enemy(x, y))
                    break
        player = Player()
        return goal_rect, coins, enemies, player

    goal_rect, coins, enemies, player = restart_game()
    sound_enabled = True  # Estado del sonido

    while ticking:
        state, sound_enabled = main_menu(sound_enabled)  # Regresa al menú después de cada partida
        paused = False
        game_over = False
        win = False
        
        while state == "start" and not game_over and not win:
            screen.blit(background, (0, 0))  # Dibujar el fondo con la imagen

            keys = pygame.key.get_pressed()
            player.move(keys)
            
            if keys[pygame.K_SPACE]:
                player.shoot()

            player.draw()

            # Comprobar si el jugador llega a la meta
            if player.rect.colliderect(goal_rect):
                win = True

            pygame.draw.rect(screen, GREEN, goal_rect)

            # Dibujar monedas y verificar colisiones con el jugador
            for coin in coins[:]:
                coin.draw()
                if player.rect.colliderect(coin.rect):
                    player.coins_collected += 1
                    coins.remove(coin)

            # Mover y dibujar enemigos
            for enemy in enemies[:]:
                enemy.move(player)
                enemy.draw()
                enemy.attack(player)
                if enemy.hit_by_bullet(player.bullets):
                    enemies.remove(enemy)

            # Verificar si el jugador es tocado por algún enemigo
            for enemy in enemies:
                if player.rect.colliderect(enemy.rect):
                    game_over = True
                    break

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    ticking = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_2:
                        paused = not paused
                    if event.key == pygame.K_ESCAPE:
                        game_over = True
                        break

            pygame.display.flip()
            clock.tick(60)

        # Mostrar mensaje de victoria o derrota
        if win:
            draw_text("¡Ganaste!", WIDTH//2 - 80, HEIGHT//2, RED)
        if game_over:
            draw_text("¡Perdiste!", WIDTH//2 - 80, HEIGHT//2, RED)

        pygame.display.flip()
        pygame.time.wait(2000)  # Esperar 2 segundos antes de reiniciar el juego

        # Reiniciar el juego
        goal_rect, coins, enemies, player = restart_game()

    
    # Cargar la imagen de fondo
    try:
        background = pygame.image.load("background.jpg")
        background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Escalamos la imagen al tamaño de la pantalla
    except pygame.error:
        print("No se pudo cargar la imagen 'background1.jpg'. Usando color de fondo.")
        background = pygame.Surface((WIDTH, HEIGHT))  # Superficie de reemplazo en caso de error
        background.fill(WHITE)

    # Definir la meta (meta de destino)
    goal_rect = pygame.Rect(WIDTH - 100, HEIGHT - 100, 50, 50)  # Rectángulo de la meta en la esquina inferior derecha
    
    # Crear las monedas en diferentes posiciones
    coins = [
        Coin(150, 200), 
        Coin(350, 300), 
        Coin(600, 250),
        Coin(500, 100),
        Coin(200, 500)
        
    ]
    
    # Crear enemigos en posiciones alejadas del jugador
    enemies = []
    for _ in range(5):
        # Evitamos que los enemigos aparezcan cerca del jugador
        while True:
            x = random.randint(200, WIDTH - 200)  # Aseguramos que estén alejados de las áreas cercanas al jugador
            y = random.randint(200, HEIGHT - 200)
            if abs(x - 100) > 100 and abs(y - 100) > 100:  # Aseguramos que estén lejos del jugador
                enemies.append(Enemy(x, y))
                break
    
    sound_enabled = True  # Estado del sonido
    
    while ticking:
        state, sound_enabled = main_menu(sound_enabled)  # Regresa al menú después de cada partida
        paused = False
        game_over = False
        win = False
        player = Player()
        
        while state == "start" and not game_over and not win:
            screen.blit(background, (0, 0))  # Dibujar el fondo con la imagen

            keys = pygame.key.get_pressed()
            player.move(keys)
            
            # Si se presiona la tecla de espacio, disparar
            if keys[pygame.K_SPACE]:
                player.shoot()

            player.draw()

            # Comprobar si el jugador llega a la meta
            if player.rect.colliderect(goal_rect):
                win = True

            # Dibujar la meta
            pygame.draw.rect(screen, GREEN, goal_rect)

            # Dibujar monedas y verificar colisiones con el jugador
            for coin in coins[:]:
                coin.draw()
                if player.rect.colliderect(coin.rect):
                    player.coins_collected += 1  # Incrementar las monedas recogidas
                    coins.remove(coin)  # Eliminar la moneda recogida

            # Mover y dibujar enemigos
            for enemy in enemies[:]:
                enemy.move(player)
                enemy.draw()
                enemy.attack(player)  # Los enemigos atacan al jugador
                if enemy.hit_by_bullet(player.bullets):  # Verificar si el enemigo fue golpeado por una bala
                    enemies.remove(enemy)  # Eliminar el enemigo

            # Verificar si el jugador es tocado por algún enemigo
            for enemy in enemies:
                if player.rect.colliderect(enemy.rect):
                    game_over = True
                    break

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    ticking = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_2:
                        paused = not paused
                    if event.key == pygame.K_ESCAPE:  # Si se presiona la tecla ESCAPE se sale del juego
                        game_over = True
                        break

            pygame.display.flip()
            clock.tick(60)

        if win:
            draw_text("¡Ganaste!", WIDTH//2 - 80, HEIGHT//2, RED)
            pygame.display.flip()
            pygame.time.wait(2000)  # Pausa de 2 segundos

        if game_over:
            draw_text("Game Over", WIDTH//2 - 80, HEIGHT//2, RED)
            pygame.display.flip()
            pygame.time.wait(2000)  # Pausa de 2 segundos


if __name__ == "__main__":
    game_loop()
